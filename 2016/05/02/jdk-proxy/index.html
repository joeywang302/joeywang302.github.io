<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>理解JDK中的动态代理实现 | Joey&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="参考资料[1] JDK动态代理实现原理[2] java动态代理（JDK和cglib）
代理模式是常用的设计模式之一，在代理模式中代理类与委托类实现相同的接口，对外暴露代理类，代理类可以在直接调用委托类代码之前为其进行额外的处理，包括事前与事后处理。代理模式的实现可以分为两种，一种是静态代理，一种是动态代理。
1. 静态代理静态代理比较简单，在编译完成后从生成的字节码中就确定了代理类的实现。
1.1">
<meta property="og:type" content="article">
<meta property="og:title" content="理解JDK中的动态代理实现">
<meta property="og:url" content="http://yoursite.com/2016/05/02/jdk-proxy/index.html">
<meta property="og:site_name" content="Joey's Blog">
<meta property="og:description" content="参考资料[1] JDK动态代理实现原理[2] java动态代理（JDK和cglib）
代理模式是常用的设计模式之一，在代理模式中代理类与委托类实现相同的接口，对外暴露代理类，代理类可以在直接调用委托类代码之前为其进行额外的处理，包括事前与事后处理。代理模式的实现可以分为两种，一种是静态代理，一种是动态代理。
1. 静态代理静态代理比较简单，在编译完成后从生成的字节码中就确定了代理类的实现。
1.1">
<meta property="og:updated_time" content="2016-05-02T15:02:29.946Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="理解JDK中的动态代理实现">
<meta name="twitter:description" content="参考资料[1] JDK动态代理实现原理[2] java动态代理（JDK和cglib）
代理模式是常用的设计模式之一，在代理模式中代理类与委托类实现相同的接口，对外暴露代理类，代理类可以在直接调用委托类代码之前为其进行额外的处理，包括事前与事后处理。代理模式的实现可以分为两种，一种是静态代理，一种是动态代理。
1. 静态代理静态代理比较简单，在编译完成后从生成的字节码中就确定了代理类的实现。
1.1">
  
    <link rel="alternate" href="/atom.xml" title="Joey&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Joey&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一步一个脚印</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-jdk-proxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/02/jdk-proxy/" class="article-date">
  <time datetime="2016-05-02T14:29:46.000Z" itemprop="datePublished">2016-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      理解JDK中的动态代理实现
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参考资料<br>[1] <a href="http://rejoy.iteye.com/blog/1627405?page=2#comments" target="_blank" rel="external">JDK动态代理实现原理</a><br>[2] <a href="http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html" target="_blank" rel="external">java动态代理（JDK和cglib）</a></p>
<p>代理模式是常用的设计模式之一，在代理模式中代理类与委托类实现相同的接口，对外暴露代理类，代理类可以在直接调用委托类代码之前为其进行额外的处理，包括事前与事后处理。代理模式的实现可以分为两种，一种是静态代理，一种是动态代理。</p>
<h1 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1. 静态代理"></a>1. 静态代理</h1><p>静态代理比较简单，在编译完成后从生成的字节码中就确定了代理类的实现。</p>
<h2 id="1-1-接口类MyService-java"><a href="#1-1-接口类MyService-java" class="headerlink" title="1.1 接口类MyService.java"></a>1.1 接口类MyService.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-接口实现类（委托类）MyServiceImpl-java"><a href="#1-2-接口实现类（委托类）MyServiceImpl-java" class="headerlink" title="1.2 接口实现类（委托类）MyServiceImpl.java"></a>1.2 接口实现类（委托类）MyServiceImpl.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceImpl</span> <span class="keyword">implements</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----------------doSomething---------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-代理类MyServiceProxy-java"><a href="#1-3-代理类MyServiceProxy-java" class="headerlink" title="1.3 代理类MyServiceProxy.java"></a>1.3 代理类MyServiceProxy.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceProxy</span> <span class="keyword">implements</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托类引用</span></span><br><span class="line">    MyService myServiceImpl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyServiceProxy</span><span class="params">(MyService myServiceImpl)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 持有委托类对象</span></span><br><span class="line">        <span class="keyword">this</span>.myServiceImpl = myServiceImpl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------------------before------------------"</span>);</span><br><span class="line">        <span class="comment">// 调用委托类实现的方法</span></span><br><span class="line">        myServiceImpl.doSomething();</span><br><span class="line">        System.out.println(<span class="string">"------------------after-------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-测试类MyServiceProxyTest-java"><a href="#1-4-测试类MyServiceProxyTest-java" class="headerlink" title="1.4 测试类MyServiceProxyTest.java"></a>1.4 测试类MyServiceProxyTest.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建委托类实例</span></span><br><span class="line">        MyService myServiceImpl = <span class="keyword">new</span> MyServiceImpl();</span><br><span class="line">        <span class="comment">// 创建代理类实例，委托类对象作为构造方法的入参</span></span><br><span class="line">        MyServiceProxy myServiceProxy = <span class="keyword">new</span> MyServiceProxy(myServiceImpl);</span><br><span class="line">        <span class="comment">// 通过代理类实例调用接口方法</span></span><br><span class="line">        myServiceProxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">------------------before------------------</span><br><span class="line">----------------doSomething---------------</span><br><span class="line">------------------after-------------------</span><br></pre></td></tr></table></figure></p>
<h2 id="1-5-静态代理要点"><a href="#1-5-静态代理要点" class="headerlink" title="1.5 静态代理要点"></a>1.5 静态代理要点</h2><ol>
<li>静态类和委托类实现相同的接口，也就是实现的方法相同。</li>
<li>静态类需要持有委托类的对象</li>
<li>需要调用代理类实现的方法，在代理类的方法中调用委托类方法。</li>
</ol>
<h1 id="2-动态代理的JDK实现"><a href="#2-动态代理的JDK实现" class="headerlink" title="2. 动态代理的JDK实现"></a>2. 动态代理的JDK实现</h1><p>静态代理解决了基本的代理问题，但是有不少缺陷。</p>
<ol>
<li>当前示例代码中代理类实现的接口仅有一个方法，如果委托类实现了多个接口，或者实现的接口方法较多，那么代理类需要每个方法都要编码实现一次，这样就产生了大量的重复代码。</li>
<li>在代码级别就已经写死了委托类和代理类的关系，某一代理类只能代理代理某一固定委托类，这种实现并不灵活。</li>
<li>当委托类实现的接口方法发生改变，那么代理类中的实现也要跟着做变更，一次变更多次修改代码，不利于开发维护。</li>
</ol>
<p>动态代理能够解决上述问题，动态代理的JDK实现以<code>InvocationHandler</code>为中转，利用<code>InovationHandler</code>代替代理类持有委托类对象，可以动态的加载任意委托类，JDK为其生成相应的代理类。</p>
<h2 id="2-1-InvocationHandler接口"><a href="#2-1-InvocationHandler接口" class="headerlink" title="2.1 InvocationHandler接口"></a>2.1 InvocationHandler接口</h2><p>动态代理的JDK实现中需要一个调用管理类代替代理类持有委托类对象,而这个代理类需要实现<code>InvocationHandler</code>接口，首先看接口的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InvocationHander</code>只有一个方法<code>invoke</code>，该方法提供给代理类，用来调用委托类的某一方法。<code>invoke</code>方法有三个参数:</p>
<ol>
<li>proxy：调用invoke方法的代理类实例。<strong>为什么需要将proxy实例传入invoke方法？暂时没想到使用场景。</strong></li>
<li>method: 委托类实现的某个接口中的某一个方法。</li>
<li>args: 该方法的参数</li>
</ol>
<p><code>invoke</code>返回对应方法的返回值。</p>
<h2 id="2-2-调用管理器MyInvocationHandler-java"><a href="#2-2-调用管理器MyInvocationHandler-java" class="headerlink" title="2.2 调用管理器MyInvocationHandler.java"></a>2.2 调用管理器MyInvocationHandler.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 持有委托类实例对象</span></span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------------------before------------------"</span>);</span><br><span class="line">        <span class="comment">// 调用委托类方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"------------------after-------------------"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代理类实例化</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                                      target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中也可以看出，调用管理器主要完成如下事项：</p>
<ol>
<li>代替代理类持有委托类实例，在代码中以构造器入参的形式传入委托类实例。</li>
<li>实现invoke方法供代理类调用。</li>
<li>调用委托类之前的事务处理也在invoke内完成。</li>
<li>生成代理类对象并返回。</li>
</ol>
<p>从代码上看，关键的实现代码是调用方法<code>Proxy.newProxyInstance</code>生成对应的代理类，具体内部如何生成，下面章节进行分析。先看看动态代理如何使用。</p>
<h2 id="2-3-调用管理器测试MyInvocationHandlerTest-java"><a href="#2-3-调用管理器测试MyInvocationHandlerTest-java" class="headerlink" title="2.3 调用管理器测试MyInvocationHandlerTest.java"></a>2.3 调用管理器测试MyInvocationHandlerTest.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 委托类实例</span></span><br><span class="line">        MyService myService = <span class="keyword">new</span> MyServiceImpl();</span><br><span class="line">        <span class="comment">// 调用管理器实例，传入委托类实例</span></span><br><span class="line">        MyInvocationHandler myInvocationHandler = <span class="keyword">new</span> MyInvocationHandler(myService);</span><br><span class="line">        <span class="comment">// 获取代理类对象</span></span><br><span class="line">        MyService proxy = (MyService) myInvocationHandler.getProxy();</span><br><span class="line">        <span class="comment">// 通过代理类调用委托类方法</span></span><br><span class="line">        proxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-代理类的实例化"><a href="#2-4-代理类的实例化" class="headerlink" title="2.4 代理类的实例化"></a>2.4 代理类的实例化</h2><p>在<code>MyInvocationHandler</code>的代理类实例化过程中调用了<code>Proxy.newProxyInstance</code>方法，这个方法到底做了什么样的事情，需要进一步到JDK源码中分析。</p>
<p><code>java.lang.reflect.Proxy</code>提供静态方法创建动态代理类，首先来看静态方法<code>newProxyInstance</code>。</p>
<h3 id="2-4-1-newProxyInstance方法"><a href="#2-4-1-newProxyInstance方法" class="headerlink" title="2.4.1 newProxyInstance方法"></a>2.4.1 newProxyInstance方法</h3><p>newProxyInstance方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span><br><span class="line">                                      Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                      InvocationHandler h)</span></span><br><span class="line">                                      <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure></p>
<p>看到一个没见过的注解<code>@CallerSensitive</code>，这个注解起什么作用呢，<a href="http://openjdk.java.net/jeps/176" target="_blank" rel="external">JEP176</a>文档中这么说，按照我的理解，感觉是这样的：<br> <code>CallerSensitive</code>注解的方法对调用者比较敏感，当获取调用者的时候需要确切的知道是哪个Caller。在反射中Method.invoke某个方法的话，method会被认为是调用者。使用<code>CallerSensitive</code>注解就是在遇到反射调用的情况时，继续寻找真正的调用者而不是直接返回反射调用。<strong>从阅读文档得到的信息中是这么说的，但是从没接触过这个注解，具体是何含义有何作用还需要继续学习体会。</strong></p>
<p><code>@CallerSensitive</code>注解的作用是题外话，主要来看<code>newProxyInstance</code>的参数。</p>
<ol>
<li>loader: 类加载器，作用是将后面生成的代理类实例加载进来。</li>
<li>interfaces: 委托类实现的接口，需要知道这些接口来生成代理类字节码，代理类也需要实现这些接口。</li>
<li>h: 调用管理器，代理类需要持有该调用管理器来invoke具体的方法。Proxy类有一个protected的构造器，入参就是调用管理器，从这儿将h传进去。</li>
</ol>
<p>最重要的还是来看newProxyInstance方法，直接看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span><br><span class="line">                                      Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// h不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 较老版本的代码是没有作clone的，为什么要做clone呢？</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="comment">// 新版代码也添加了安全方面SecurityManager的检查</span></span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最重要的部分，根据传入的类加载器和实现的接口类生成代理类的字节码，并加载进来</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取代理类的构造器，并完成实例化</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// constructorParams中只有一项InvocationHander.class</span></span><br><span class="line">        <span class="comment">// 生成的代理类继承Proxy类，Proxy类有一个构造方法需要InvocationHandler参数</span></span><br><span class="line">        <span class="comment">// Proxy持有InvocationHandler实例的引用</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span> &amp;&amp; ProxyAccessHelper.needsNewInstanceCheck(cl)) &#123;</span><br><span class="line">            <span class="comment">// 安全方面的代码，最终目的还是进行实例化</span></span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//执行实例化</span></span><br><span class="line">                    <span class="keyword">return</span> newInstance(cons, ih);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//执行实例化</span></span><br><span class="line">            <span class="keyword">return</span> newInstance(cons, ih);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到主要有两个关键阶段，一个是根据传入的类加载器和委托类实现的接口生成代理类的字节码，并加载，二是找到构造器，执行实例化并返回。</p>
<p>执行实例化的方法<code>newInstance</code>没什么好说的，就是执行<code>Constructor.newInstance()</code>。但是有个地方要说明一下，生成的代理类是类似于<code>Class XXXX extends Proxy implements XXXX, XXXX, XXX</code>，就是代理类继承了<code>Proxy</code>，并且实现了委托类的若干接口。Proxy类有两个构造器，一个是无参数Public构造器，一个是以<code>InvocationHandler</code>为入参的Protected构造器，后者显然是给内部用的，用处就是此处的代理类实例化。</p>
<p>下面接着看生成和加载代理类的方法<code>getProxyClass0</code>。</p>
<h3 id="2-4-2-getProxyClass0方法"><a href="#2-4-2-getProxyClass0方法" class="headerlink" title="2.4.2 getProxyClass0方法"></a>2.4.2 getProxyClass0方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果对应loader和interfaces的代理类已经生成过了，那么直接从proxyClassCache中取</span></span><br><span class="line">    <span class="comment">// 如果没有，则由ProxyClassFactory负责生成代理类</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法非常简单，也是JDK动态代理源码实现变动比较大的地方，原来是使用一个HashMap，现在使用一个proxyClassCache的数据结构维护类加载器、接口、代理类。</p>
<h3 id="2-4-3-proxyClassCache数据结构"><a href="#2-4-3-proxyClassCache数据结构" class="headerlink" title="2.4.3 proxyClassCache数据结构"></a>2.4.3 proxyClassCache数据结构</h3><p><code>proxyClassCache</code>是如何维护这些关系，并启动代理类的生成的？先看它的声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure>
<p><code>proxyClassCache</code>是一种<code>WeakCache</code>容器（<strong>为什么是WeakCache？怎么考虑的？WeakCache的资料非常少后续还需要深入学习</strong>)。<code>WeakCache</code>也是一种键值对的容器(<k,p,v>)，但是它的键是组合键，有两部分决定：Key与Param，对应于<code>proxyClassCache</code>，Key就是ClassLoader，Param就是接口类，值就是对应的代理类。<code>proxyClassCache</code>使用的构造器有两个参数<code>KeyFactory</code>和<code>ProxyClassFactory</code>，这是WeakCache提供的构造器，KeyFactory用来生成组合键，K与P通过KeyFactory生成一个或者一组WeakReference，并提供equal方法。ProxyClassFactory是在WeakCache查不到对应结果时生成V的工厂类。</k,p,v></p>
<p><strong>从本质上来讲，WeakCache还是一个Map，只是它添加了一个组合键的特性，两个回调的Factory。</strong></p>
<p>如何利用KeyFactory来生成组合键不是动态代理的重点，只要知道KeyFactory能够提供一个Key并实现equal方法即可，如果想知道更多的细节阅读源码即可。</p>
<p>到目前为止，代理类还是没有生成，那什么时候生成呢？当getProxyClass0从proxyCache中取代理类时，如果proxyCache中没有相关的记录，那么proxyCache就会利用proxyClassFactory去生成这个代理类，并放入proxyCache中。所以代理类的生成在proxyClassFactory中。</p>
<h3 id="2-4-4-ProxyClassFactory工厂类"><a href="#2-4-4-ProxyClassFactory工厂类" class="headerlink" title="2.4.4 ProxyClassFactory工厂类"></a>2.4.4 ProxyClassFactory工厂类</h3><p>ProxyClassFactory类有一个public方法apply，用来生成代理类，还是直接看代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // 生成的代理类的前缀</span><br><span class="line">    private static final String proxyClassNamePrefix = "$Proxy";</span><br><span class="line">    private static final AtomicLong nextUniqueNumber = new AtomicLong();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        // 挨个检查intefaces，然后使用loader加载进来</span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">        for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            Class&lt;?&gt; interfaceClass = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 两个目的，一个是检查inteface，一个是未加载进来的加载进来</span><br><span class="line">                interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            // 检查interface的属性，是不是interface？有没有重复？</span><br><span class="line">            // ... ...</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断生成的代理类应该在哪个package中</span><br><span class="line">        // ... ...</span><br><span class="line">        // 生成代理类名</span><br><span class="line">        long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        // 这儿就是具体生成代理类字节码的代码</span><br><span class="line">        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces);</span><br><span class="line">        try &#123;</span><br><span class="line">            // 这里是调用native方法defineClass0加载代理类的代码</span><br><span class="line">            return defineClass0(loader, proxyName,</span><br><span class="line">                                proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">        &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">            throw new IllegalArgumentException(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体ProxyGenerator.generateProxyClass如何生成代理类的字节码就比较烦琐了，主要知道它做了两件事情，生成代理类字节码、将字节码文件写入磁盘。然后native方法defineClass0从磁盘中将字节码加载。</p>
<h3 id="2-4-5-自己生成一个代理类字节码"><a href="#2-4-5-自己生成一个代理类字节码" class="headerlink" title="2.4.5 自己生成一个代理类字节码"></a>2.4.5 自己生成一个代理类字节码</h3><p>既然知道ProxyGenerator能够生成代理类字节码，那我们也能自己生成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyGeneratorUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeProxyClassToHardDisk</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成代理类的字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(<span class="string">"$Proxy11"</span>, MyServiceImpl.class.getInterfaces());</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 写入文件</span></span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(path);</span><br><span class="line">            out.write(classFile);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyGeneratorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyGeneratorUtils.writeProxyClassToHardDisk(<span class="string">"$Proxy11.class"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的class文件通过DJ Java Decompile反编译，得到的Java代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Decompiled by DJ v3.12.12.99 Copyright 2015 Atanas Neshkov  Date: 2015/6/12 16:51:04</span></span><br><span class="line"><span class="comment">// Home Page:  http://www.neshkov.com/dj.html - Check often for new version!</span></span><br><span class="line"><span class="comment">// Decompiler options: packimports(3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.app.myinvocationhandler.MyService;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="comment">// 生成的代理类 继承Proxy，实现MyService接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy11</span> <span class="keyword">extends</span> <span class="title">Proxy</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title">MyService</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造器接收InvocationHandler作为入参，实际上是给Proxy构造器使用的</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy11(InvocationHandler invocationhandler)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(invocationhandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 调用的是委托类的equal方法</span></span><br><span class="line">            <span class="keyword">return</span> ((Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                obj</span><br><span class="line">            &#125;)).booleanValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Error _ex) &#123; &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Throwable throwable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//调用委托类的hashCode方法</span></span><br><span class="line">            <span class="keyword">return</span> ((Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, <span class="keyword">null</span>)).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Error _ex) &#123; &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Throwable throwable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 调用委托类的方法，通过Proxy持有的InvocationHandler的invoke方法调用</span></span><br><span class="line">            <span class="comment">// invoke方法中的其他事务处理也在此处被调用</span></span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Error _ex) &#123; &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Throwable throwable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Error _ex) &#123; &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Throwable throwable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三个Object的方法，一个MyService的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;   <span class="comment">//equals</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;   <span class="comment">//hashCode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;   <span class="comment">//doSomething</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;   <span class="comment">//toString</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                Class.forName(<span class="string">"java.lang.Object"</span>)</span><br><span class="line">            &#125;);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.alibaba.app.myinvocationhandler.MyService"</span>).getMethod(<span class="string">"doSomething"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(NoSuchMethodException nosuchmethodexception)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(nosuchmethodexception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException classnotfoundexception)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(classnotfoundexception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从查阅得到的资料看，Spring支持两种动态代理方法，一种是JDK实现的字节码生成，另外一种是Cglib的ASM生成代理，C glib创建代理类的速度比JDK慢，但是执行速度要比JDK快（<strong>两者性能差异来源是？？？</strong>）。在使用上两者主要的差别是JDK是代理接口，如果某类没有实现某个接口，其方法没有接口化，那么JDK无法完成代理。</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>这次的学习总结是在文杰推荐的博文基础上完成的，博文中贴出了JDK源代码，但是在自己进行实践去看JDK7源代码的时候，发现源码已经发生了改变，特别是在WeakCache数据结构上改动比较大。从阅读源码的角度去理解动态代理更加深入。在未阅读之前，可能只是知道动态代理的使用，如何传参等等，深入学习之后才能够理解这些参数都是如何被使用。现在看来，动态代理的实现主要完成了两件事情：loader、interface、代理类class关系的维护，代理类字节码的生成与载入。</p>
<p>另外在总结过程中，一边思考也积攒了一些问题（<strong>文中加粗段</strong>），希望后面的学习更广更深之后能解决这些疑惑。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/02/jdk-proxy/" data-id="cinq3rfon0000xwwlr8j661z4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-JDK-动态代理-Cglib/">Java JDK 动态代理 Cglib</a></li></ul>

    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-JDK-动态代理-Cglib/">Java JDK 动态代理 Cglib</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java-JDK-动态代理-Cglib/" style="font-size: 10px;">Java JDK 动态代理 Cglib</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/05/02/jdk-proxy/">理解JDK中的动态代理实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Joey Wang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>